El **riesgo** mide la probabilidad de que algo salga mal y el impacto que tendría ese fallo en el sistema. En base al riesgo, podemos priorizar qué partes del software necesitan más pruebas y cuáles pueden ser probadas con menos intensidad.

cap 11 pmbok

Risk is based on two factors – the likelihood of the problem occurring and the impact of the problem when it does occur. For example, if a particular piece of code is complex then it will introduce far more errors than a simple module of code. Or a particular module of code could be critical to the success of the product. Without it functioning perfectly, the product simply will not deliver its intended result. Both of these areas should receive more attention and more testing than less 'risky' areas. But how to identify those areas of risk? As already mentioned, complexity is a good proxy for probability – the more complex the code the more likely it is that an error will be introduced. In existing code, the historical location of defects can be a good guide to likely areas of complexity. In new code, effort or duration can be good proxies for complexity – the more complex or difficult the code, the longer it will take to write. But impact or criticality is much harder to measure. Business value can be a proxy for criticality, but not always. Business users might not regard the phone or the internet as highly valuable but they are critical pieces of infrastructure that they would struggle to operate without them. What we need therefore is a recursive model of the software to help guide our testing.